
C:\Users\m039\AppData\Local\arduino\sketches\92FB84DE939F348C63473E9514D5475B/LedKeychainATtiny85.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	1e c0       	rjmp	.+60     	; 0x3e <__ctors_end>
   2:	37 c0       	rjmp	.+110    	; 0x72 <__bad_interrupt>
   4:	36 c0       	rjmp	.+108    	; 0x72 <__bad_interrupt>
   6:	35 c0       	rjmp	.+106    	; 0x72 <__bad_interrupt>
   8:	34 c0       	rjmp	.+104    	; 0x72 <__bad_interrupt>
   a:	04 c1       	rjmp	.+520    	; 0x214 <__vector_5>
   c:	32 c0       	rjmp	.+100    	; 0x72 <__bad_interrupt>
   e:	31 c0       	rjmp	.+98     	; 0x72 <__bad_interrupt>
  10:	30 c0       	rjmp	.+96     	; 0x72 <__bad_interrupt>
  12:	2f c0       	rjmp	.+94     	; 0x72 <__bad_interrupt>
  14:	2e c0       	rjmp	.+92     	; 0x72 <__bad_interrupt>
  16:	2d c0       	rjmp	.+90     	; 0x72 <__bad_interrupt>
  18:	2c c0       	rjmp	.+88     	; 0x72 <__bad_interrupt>
  1a:	2b c0       	rjmp	.+86     	; 0x72 <__bad_interrupt>
  1c:	2a c0       	rjmp	.+84     	; 0x72 <__bad_interrupt>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	01 03       	mulsu	r16, r17
  20:	00 00       	nop
  22:	04 00       	.word	0x0004	; ????

00000024 <port_to_output_PGM>:
  24:	00 00 00 00 38 00                                   ....8.

0000002a <port_to_mode_PGM>:
  2a:	00 00 00 00 37 00                                   ....7.

00000030 <digital_pin_to_port_PGM>:
  30:	02 02 02 02 02 02                                   ......

00000036 <digital_pin_to_bit_mask_PGM>:
  36:	01 02 04 08 10 20                                   ..... 

0000003c <__ctors_start>:
__ctors_start():
  3c:	8d 02       	muls	r24, r29

0000003e <__ctors_end>:
__dtors_end():
  3e:	11 24       	eor	r1, r1
  40:	1f be       	out	0x3f, r1	; 63
  42:	cf e5       	ldi	r28, 0x5F	; 95
  44:	d2 e0       	ldi	r29, 0x02	; 2
  46:	de bf       	out	0x3e, r29	; 62
  48:	cd bf       	out	0x3d, r28	; 61

0000004a <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  4a:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  4c:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  4e:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  50:	01 c0       	rjmp	.+2      	; 0x54 <.do_clear_bss_start>

00000052 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  52:	1d 92       	st	X+, r1

00000054 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  54:	aa 3d       	cpi	r26, 0xDA	; 218
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  56:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  58:	e1 f7       	brne	.-8      	; 0x52 <.do_clear_bss_loop>

0000005a <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  5a:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  5c:	cf e1       	ldi	r28, 0x1F	; 31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  5e:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  60:	03 c0       	rjmp	.+6      	; 0x68 <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  62:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  64:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  66:	bb d2       	rcall	.+1398   	; 0x5de <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  68:	ce 31       	cpi	r28, 0x1E	; 30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  6a:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  6c:	d1 f7       	brne	.-12     	; 0x62 <__do_global_ctors+0x8>
  6e:	40 d1       	rcall	.+640    	; 0x2f0 <main>
  70:	bc c2       	rjmp	.+1400   	; 0x5ea <_exit>

00000072 <__bad_interrupt>:
__vector_1():
  72:	c6 cf       	rjmp	.-116    	; 0x0 <__vectors>

00000074 <digitalWrite>:
digitalWrite():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:138
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  74:	87 ff       	sbrs	r24, 7
  76:	09 c0       	rjmp	.+18     	; 0x8a <digitalWrite+0x16>
  78:	8f 77       	andi	r24, 0x7F	; 127
  7a:	71 f1       	breq	.+92     	; 0xd8 <digitalWrite+0x64>
  7c:	81 30       	cpi	r24, 0x01	; 1
  7e:	71 f1       	breq	.+92     	; 0xdc <digitalWrite+0x68>
  80:	82 30       	cpi	r24, 0x02	; 2
  82:	71 f1       	breq	.+92     	; 0xe0 <digitalWrite+0x6c>
  84:	83 30       	cpi	r24, 0x03	; 3
  86:	71 f1       	breq	.+92     	; 0xe4 <digitalWrite+0x70>
  88:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:139
  uint8_t timer = digitalPinToTimer(pin);
  8a:	90 e0       	ldi	r25, 0x00	; 0
  8c:	fc 01       	movw	r30, r24
  8e:	e2 5e       	subi	r30, 0xE2	; 226
  90:	ff 4f       	sbci	r31, 0xFF	; 255
  92:	34 91       	lpm	r19, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:140
  uint8_t bit = digitalPinToBitMask(pin);
  94:	fc 01       	movw	r30, r24
  96:	ea 5c       	subi	r30, 0xCA	; 202
  98:	ff 4f       	sbci	r31, 0xFF	; 255
  9a:	24 91       	lpm	r18, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:141
  uint8_t port = digitalPinToPort(pin);
  9c:	fc 01       	movw	r30, r24
  9e:	e0 5d       	subi	r30, 0xD0	; 208
  a0:	ff 4f       	sbci	r31, 0xFF	; 255
  a2:	e4 91       	lpm	r30, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:144
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
  a4:	ee 23       	and	r30, r30
  a6:	b9 f0       	breq	.+46     	; 0xd6 <digitalWrite+0x62>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:148

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  a8:	33 23       	and	r19, r19
  aa:	29 f0       	breq	.+10     	; 0xb6 <digitalWrite+0x42>
turnOffPWM():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
    if( timer == TIMER0A){
  ac:	31 30       	cpi	r19, 0x01	; 1
  ae:	e1 f4       	brne	.+56     	; 0xe8 <digitalWrite+0x74>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:68
      cbi(TCCR0A, COM0A1);
  b0:	8a b5       	in	r24, 0x2a	; 42
  b2:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
      cbi(TCCR0A, COM0B1);
  b4:	8a bd       	out	0x2a, r24	; 42
digitalWrite():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:150

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
  b6:	f0 e0       	ldi	r31, 0x00	; 0
  b8:	ee 0f       	add	r30, r30
  ba:	ff 1f       	adc	r31, r31
  bc:	ec 5d       	subi	r30, 0xDC	; 220
  be:	ff 4f       	sbci	r31, 0xFF	; 255
  c0:	a5 91       	lpm	r26, Z+
  c2:	b4 91       	lpm	r27, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:153

  if (val == LOW) {
    uint8_t oldSREG = SREG;
  c4:	8f b7       	in	r24, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
  c6:	61 11       	cpse	r22, r1
  c8:	20 c0       	rjmp	.+64     	; 0x10a <digitalWrite+0x96>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:154
    uint8_t oldSREG = SREG;
    cli();
  ca:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
  cc:	ec 91       	ld	r30, X
  ce:	20 95       	com	r18
  d0:	2e 23       	and	r18, r30
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
  d2:	2c 93       	st	X, r18
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
  d4:	8f bf       	out	0x3f, r24	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:163
  }
}
  d6:	08 95       	ret
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:138
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  d8:	85 e0       	ldi	r24, 0x05	; 5
  da:	d7 cf       	rjmp	.-82     	; 0x8a <digitalWrite+0x16>
  dc:	82 e0       	ldi	r24, 0x02	; 2
  de:	d5 cf       	rjmp	.-86     	; 0x8a <digitalWrite+0x16>
  e0:	84 e0       	ldi	r24, 0x04	; 4
  e2:	d3 cf       	rjmp	.-90     	; 0x8a <digitalWrite+0x16>
  e4:	83 e0       	ldi	r24, 0x03	; 3
  e6:	d1 cf       	rjmp	.-94     	; 0x8a <digitalWrite+0x16>
turnOffPWM():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:73
      cbi(TCCR0A, COM0A1);
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
  e8:	32 30       	cpi	r19, 0x02	; 2
  ea:	19 f4       	brne	.+6      	; 0xf2 <digitalWrite+0x7e>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      cbi(TCCR0A, COM0B1);
  ec:	8a b5       	in	r24, 0x2a	; 42
  ee:	8f 7d       	andi	r24, 0xDF	; 223
  f0:	e1 cf       	rjmp	.-62     	; 0xb4 <digitalWrite+0x40>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:106
      //cbi(TCCR1C,COM1D0);
    } else
  #else
    // Timer1 for non-x61/x7
    #if defined(TCCR1) && defined(COM1A1) // x5
      if(timer == TIMER1A){
  f2:	33 30       	cpi	r19, 0x03	; 3
  f4:	21 f4       	brne	.+8      	; 0xfe <digitalWrite+0x8a>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:107
        TCCR1 &= ~(1<<COM1A1);
  f6:	80 b7       	in	r24, 0x30	; 48
  f8:	8f 7d       	andi	r24, 0xDF	; 223
  fa:	80 bf       	out	0x30, r24	; 48
  fc:	dc cf       	rjmp	.-72     	; 0xb6 <digitalWrite+0x42>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:112
        //cbi(TCCR1, COM1A0);
      } else
    #endif
    #if defined(TCCR1) && defined(COM1B1) // x5
      if( timer == TIMER1B){
  fe:	34 30       	cpi	r19, 0x04	; 4
 100:	d1 f6       	brne	.-76     	; 0xb6 <digitalWrite+0x42>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:113
        GTCCR &= ~(1<<COM1B1);
 102:	8c b5       	in	r24, 0x2c	; 44
 104:	8f 7d       	andi	r24, 0xDF	; 223
 106:	8c bd       	out	0x2c, r24	; 44
 108:	d6 cf       	rjmp	.-84     	; 0xb6 <digitalWrite+0x42>
digitalWrite():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:159
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 10a:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
 10c:	ec 91       	ld	r30, X
 10e:	2e 2b       	or	r18, r30
 110:	e0 cf       	rjmp	.-64     	; 0xd2 <digitalWrite+0x5e>

00000112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>:
_ZN10LedControl11spiTransferEihh.constprop.13():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:192
        v|=B10000000;
    status[offset+digit]=v;
    spiTransfer(addr, digit+1,v);
}

void LedControl::spiTransfer(int addr, volatile byte opcode, volatile byte data) {
 112:	af 92       	push	r10
 114:	bf 92       	push	r11
 116:	cf 92       	push	r12
 118:	df 92       	push	r13
 11a:	ef 92       	push	r14
 11c:	ff 92       	push	r15
 11e:	0f 93       	push	r16
 120:	1f 93       	push	r17
 122:	cf 93       	push	r28
 124:	df 93       	push	r29
 126:	00 d0       	rcall	.+0      	; 0x128 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0x16>
 128:	cd b7       	in	r28, 0x3d	; 61
 12a:	de b7       	in	r29, 0x3e	; 62
 12c:	69 83       	std	Y+1, r22	; 0x01
 12e:	4a 83       	std	Y+2, r20	; 0x02
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:194
    //Create an array with the data to shift out
    int offset=addr*2;
 130:	88 0f       	add	r24, r24
 132:	99 1f       	adc	r25, r25
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:195
    int maxbytes=maxDevices*2;
 134:	00 91 d8 00 	lds	r16, 0x00D8	; 0x8000d8 <lc+0x56>
 138:	10 91 d9 00 	lds	r17, 0x00D9	; 0x8000d9 <lc+0x57>
 13c:	00 0f       	add	r16, r16
 13e:	11 1f       	adc	r17, r17
 140:	e2 e8       	ldi	r30, 0x82	; 130
 142:	f0 e0       	ldi	r31, 0x00	; 0
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:197

    for(int i=0;i<maxbytes;i++)
 144:	9f 01       	movw	r18, r30
 146:	22 58       	subi	r18, 0x82	; 130
 148:	30 40       	sbci	r19, 0x00	; 0
 14a:	20 17       	cp	r18, r16
 14c:	31 07       	cpc	r19, r17
 14e:	14 f4       	brge	.+4      	; 0x154 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0x42>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:198
        spidata[i]=(byte)0;
 150:	11 92       	st	Z+, r1
 152:	f8 cf       	rjmp	.-16     	; 0x144 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0x32>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:200
    //put our device data into the array
    spidata[offset+1]=opcode;
 154:	29 81       	ldd	r18, Y+1	; 0x01
 156:	fc 01       	movw	r30, r24
 158:	ee 57       	subi	r30, 0x7E	; 126
 15a:	ff 4f       	sbci	r31, 0xFF	; 255
 15c:	21 83       	std	Z+1, r18	; 0x01
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:201
    spidata[offset]=data;
 15e:	8a 81       	ldd	r24, Y+2	; 0x02
 160:	80 83       	st	Z, r24
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:203
    //enable the line 
    digitalWrite(SPI_CS,LOW);
 162:	60 e0       	ldi	r22, 0x00	; 0
 164:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <lc+0x54>
 168:	85 df       	rcall	.-246    	; 0x74 <digitalWrite>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:205
    //Now shift out the data 
    for(int i=maxbytes;i>0;i--)
 16a:	10 16       	cp	r1, r16
 16c:	11 06       	cpc	r1, r17
 16e:	1c f5       	brge	.+70     	; 0x1b6 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0xa4>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:206
        shiftOut(SPI_MOSI,SPI_CLK,MSBFIRST,spidata[i-1]);
 170:	01 50       	subi	r16, 0x01	; 1
 172:	11 09       	sbc	r17, r1
 174:	f8 01       	movw	r30, r16
 176:	ee 57       	subi	r30, 0x7E	; 126
 178:	ff 4f       	sbci	r31, 0xFF	; 255
 17a:	c0 80       	ld	r12, Z
 17c:	b0 90 d4 00 	lds	r11, 0x00D4	; 0x8000d4 <lc+0x52>
 180:	a0 90 d2 00 	lds	r10, 0x00D2	; 0x8000d2 <lc+0x50>
 184:	87 e0       	ldi	r24, 0x07	; 7
 186:	e8 2e       	mov	r14, r24
 188:	f1 2c       	mov	r15, r1
shiftOut():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_shift.c:50

  for (i = 0; i < 8; i++)  {
    if (bitOrder == LSBFIRST)
      digitalWrite(dataPin, !!(val & (1 << i)));
    else
      digitalWrite(dataPin, !!(val & (1 << (7 - i))));
 18a:	d1 2c       	mov	r13, r1
 18c:	b6 01       	movw	r22, r12
 18e:	0e 2c       	mov	r0, r14
 190:	02 c0       	rjmp	.+4      	; 0x196 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0x84>
 192:	75 95       	asr	r23
 194:	67 95       	ror	r22
 196:	0a 94       	dec	r0
 198:	e2 f7       	brpl	.-8      	; 0x192 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0x80>
 19a:	61 70       	andi	r22, 0x01	; 1
 19c:	8a 2d       	mov	r24, r10
 19e:	6a df       	rcall	.-300    	; 0x74 <digitalWrite>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_shift.c:52

    digitalWrite(clockPin, HIGH);
 1a0:	61 e0       	ldi	r22, 0x01	; 1
 1a2:	8b 2d       	mov	r24, r11
 1a4:	67 df       	rcall	.-306    	; 0x74 <digitalWrite>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_shift.c:53
    digitalWrite(clockPin, LOW);
 1a6:	60 e0       	ldi	r22, 0x00	; 0
 1a8:	8b 2d       	mov	r24, r11
 1aa:	64 df       	rcall	.-312    	; 0x74 <digitalWrite>
 1ac:	81 e0       	ldi	r24, 0x01	; 1
 1ae:	e8 1a       	sub	r14, r24
 1b0:	f1 08       	sbc	r15, r1
 1b2:	60 f7       	brcc	.-40     	; 0x18c <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0x7a>
 1b4:	da cf       	rjmp	.-76     	; 0x16a <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]+0x58>
_ZN10LedControl11spiTransferEihh.constprop.13():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:208
    //latch the data onto the display
    digitalWrite(SPI_CS,HIGH);
 1b6:	61 e0       	ldi	r22, 0x01	; 1
 1b8:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <lc+0x54>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:209
}    
 1bc:	0f 90       	pop	r0
 1be:	0f 90       	pop	r0
 1c0:	df 91       	pop	r29
 1c2:	cf 91       	pop	r28
 1c4:	1f 91       	pop	r17
 1c6:	0f 91       	pop	r16
 1c8:	ff 90       	pop	r15
 1ca:	ef 90       	pop	r14
 1cc:	df 90       	pop	r13
 1ce:	cf 90       	pop	r12
 1d0:	bf 90       	pop	r11
 1d2:	af 90       	pop	r10
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:208
    digitalWrite(SPI_CS,LOW);
    //Now shift out the data 
    for(int i=maxbytes;i>0;i--)
        shiftOut(SPI_MOSI,SPI_CLK,MSBFIRST,spidata[i-1]);
    //latch the data onto the display
    digitalWrite(SPI_CS,HIGH);
 1d4:	4f cf       	rjmp	.-354    	; 0x74 <digitalWrite>

000001d6 <LedControl::clearDisplay(int) [clone .part.3] [clone .constprop.10]>:
_ZN10LedControl12clearDisplayEi.part.3.constprop.10():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:99
        return;
    if(intensity>=0 && intensity<16)	
        spiTransfer(addr, OP_INTENSITY,intensity);
}

void LedControl::clearDisplay(int addr) {
 1d6:	ef 92       	push	r14
 1d8:	ff 92       	push	r15
 1da:	0f 93       	push	r16
 1dc:	1f 93       	push	r17
 1de:	cf 93       	push	r28
 1e0:	7c 01       	movw	r14, r24
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:104
    int offset;

    if(addr<0 || addr>=maxDevices)
        return;
    offset=addr*8;
 1e2:	8c 01       	movw	r16, r24
 1e4:	83 e0       	ldi	r24, 0x03	; 3
 1e6:	00 0f       	add	r16, r16
 1e8:	11 1f       	adc	r17, r17
 1ea:	8a 95       	dec	r24
 1ec:	e1 f7       	brne	.-8      	; 0x1e6 <LedControl::clearDisplay(int) [clone .part.3] [clone .constprop.10]+0x10>
 1ee:	0e 56       	subi	r16, 0x6E	; 110
 1f0:	1f 4f       	sbci	r17, 0xFF	; 255
 1f2:	c1 e0       	ldi	r28, 0x01	; 1
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:106
    for(int i=0;i<8;i++) {
        status[offset+i]=0;
 1f4:	f8 01       	movw	r30, r16
 1f6:	11 92       	st	Z+, r1
 1f8:	8f 01       	movw	r16, r30
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:107
        spiTransfer(addr, i+1,status[offset+i]);
 1fa:	40 e0       	ldi	r20, 0x00	; 0
 1fc:	6c 2f       	mov	r22, r28
 1fe:	c7 01       	movw	r24, r14
 200:	88 df       	rcall	.-240    	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
 202:	cf 5f       	subi	r28, 0xFF	; 255
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:105
    int offset;

    if(addr<0 || addr>=maxDevices)
        return;
    offset=addr*8;
    for(int i=0;i<8;i++) {
 204:	c9 30       	cpi	r28, 0x09	; 9
 206:	b1 f7       	brne	.-20     	; 0x1f4 <LedControl::clearDisplay(int) [clone .part.3] [clone .constprop.10]+0x1e>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:109
        status[offset+i]=0;
        spiTransfer(addr, i+1,status[offset+i]);
    }
}
 208:	cf 91       	pop	r28
 20a:	1f 91       	pop	r17
 20c:	0f 91       	pop	r16
 20e:	ff 90       	pop	r15
 210:	ef 90       	pop	r14
 212:	08 95       	ret

00000214 <__vector_5>:
__vector_5():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:308
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
 214:	1f 92       	push	r1
 216:	0f 92       	push	r0
 218:	0f b6       	in	r0, 0x3f	; 63
 21a:	0f 92       	push	r0
 21c:	11 24       	eor	r1, r1
 21e:	4f 93       	push	r20
 220:	5f 93       	push	r21
 222:	6f 93       	push	r22
 224:	7f 93       	push	r23
 226:	8f 93       	push	r24
 228:	9f 93       	push	r25
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:311
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
 22a:	40 91 7e 00 	lds	r20, 0x007E	; 0x80007e <millis_timer_millis>
 22e:	50 91 7f 00 	lds	r21, 0x007F	; 0x80007f <millis_timer_millis+0x1>
 232:	60 91 80 00 	lds	r22, 0x0080	; 0x800080 <millis_timer_millis+0x2>
 236:	70 91 81 00 	lds	r23, 0x0081	; 0x800081 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:312
    unsigned char f = millis_timer_fract;
 23a:	80 91 7d 00 	lds	r24, 0x007D	; 0x80007d <millis_timer_fract>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:315
#ifdef CORRECT_EXACT_MILLIS
    static unsigned char correct_exact = 0;     // rollover intended
    if (++correct_exact < CORRECT_EXACT_MANY) {
 23e:	90 91 7c 00 	lds	r25, 0x007C	; 0x80007c <correct_exact.2384>
 242:	9f 5f       	subi	r25, 0xFF	; 255
 244:	90 93 7c 00 	sts	0x007C, r25	; 0x80007c <correct_exact.2384>
 248:	9f 31       	cpi	r25, 0x1F	; 31
 24a:	08 f4       	brcc	.+2      	; 0x24e <__vector_5+0x3a>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:316
      ++f;
 24c:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:319
    }
#endif
    f += FRACT_INC;
 24e:	9c e7       	ldi	r25, 0x7C	; 124
 250:	98 0f       	add	r25, r24
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:321

    if (f >= FRACT_MAX)
 252:	9d 37       	cpi	r25, 0x7D	; 125
 254:	30 f0       	brcs	.+12     	; 0x262 <__stack+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:323
    {
      f -= FRACT_MAX;
 256:	9f ef       	ldi	r25, 0xFF	; 255
 258:	98 0f       	add	r25, r24
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:324
      m += MILLIS_INC + 1;
 25a:	4f 5f       	subi	r20, 0xFF	; 255
 25c:	5f 4f       	sbci	r21, 0xFF	; 255
 25e:	6f 4f       	sbci	r22, 0xFF	; 255
 260:	7f 4f       	sbci	r23, 0xFF	; 255
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:331
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
 262:	90 93 7d 00 	sts	0x007D, r25	; 0x80007d <millis_timer_fract>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:332
    millis_timer_millis = m;
 266:	40 93 7e 00 	sts	0x007E, r20	; 0x80007e <millis_timer_millis>
 26a:	50 93 7f 00 	sts	0x007F, r21	; 0x80007f <millis_timer_millis+0x1>
 26e:	60 93 80 00 	sts	0x0080, r22	; 0x800080 <millis_timer_millis+0x2>
 272:	70 93 81 00 	sts	0x0081, r23	; 0x800081 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:336
#ifndef CORRECT_EXACT_MICROS
    millis_timer_overflow_count++;
#endif
  }
 276:	9f 91       	pop	r25
 278:	8f 91       	pop	r24
 27a:	7f 91       	pop	r23
 27c:	6f 91       	pop	r22
 27e:	5f 91       	pop	r21
 280:	4f 91       	pop	r20
 282:	0f 90       	pop	r0
 284:	0f be       	out	0x3f, r0	; 63
 286:	0f 90       	pop	r0
 288:	1f 90       	pop	r1
 28a:	18 95       	reti

0000028c <pinMode.constprop.6>:
pinMode.constprop.6():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:34
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 28c:	87 ff       	sbrs	r24, 7
 28e:	09 c0       	rjmp	.+18     	; 0x2a2 <pinMode.constprop.6+0x16>
 290:	8f 77       	andi	r24, 0x7F	; 127
 292:	31 f1       	breq	.+76     	; 0x2e0 <pinMode.constprop.6+0x54>
 294:	81 30       	cpi	r24, 0x01	; 1
 296:	31 f1       	breq	.+76     	; 0x2e4 <pinMode.constprop.6+0x58>
 298:	82 30       	cpi	r24, 0x02	; 2
 29a:	31 f1       	breq	.+76     	; 0x2e8 <pinMode.constprop.6+0x5c>
 29c:	83 30       	cpi	r24, 0x03	; 3
 29e:	31 f1       	breq	.+76     	; 0x2ec <pinMode.constprop.6+0x60>
 2a0:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:35
  uint8_t bit = digitalPinToBitMask(pin);
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	fc 01       	movw	r30, r24
 2a6:	ea 5c       	subi	r30, 0xCA	; 202
 2a8:	ff 4f       	sbci	r31, 0xFF	; 255
 2aa:	24 91       	lpm	r18, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 2ac:	80 5d       	subi	r24, 0xD0	; 208
 2ae:	9f 4f       	sbci	r25, 0xFF	; 255
 2b0:	fc 01       	movw	r30, r24
 2b2:	84 91       	lpm	r24, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 2b4:	88 23       	and	r24, r24
 2b6:	99 f0       	breq	.+38     	; 0x2de <pinMode.constprop.6+0x52>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	88 0f       	add	r24, r24
 2bc:	99 1f       	adc	r25, r25
 2be:	fc 01       	movw	r30, r24
 2c0:	e6 5d       	subi	r30, 0xD6	; 214
 2c2:	ff 4f       	sbci	r31, 0xFF	; 255
 2c4:	a5 91       	lpm	r26, Z+
 2c6:	b4 91       	lpm	r27, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 2c8:	fc 01       	movw	r30, r24
 2ca:	ec 5d       	subi	r30, 0xDC	; 220
 2cc:	ff 4f       	sbci	r31, 0xFF	; 255
 2ce:	85 91       	lpm	r24, Z+
 2d0:	94 91       	lpm	r25, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 2d2:	8f b7       	in	r24, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:58
                cli();
 2d4:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 2d6:	ec 91       	ld	r30, X
 2d8:	e2 2b       	or	r30, r18
 2da:	ec 93       	st	X, r30
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 2dc:	8f bf       	out	0x3f, r24	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:62
  }
}
 2de:	08 95       	ret
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:34
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 2e0:	85 e0       	ldi	r24, 0x05	; 5
 2e2:	df cf       	rjmp	.-66     	; 0x2a2 <pinMode.constprop.6+0x16>
 2e4:	82 e0       	ldi	r24, 0x02	; 2
 2e6:	dd cf       	rjmp	.-70     	; 0x2a2 <pinMode.constprop.6+0x16>
 2e8:	84 e0       	ldi	r24, 0x04	; 4
 2ea:	db cf       	rjmp	.-74     	; 0x2a2 <pinMode.constprop.6+0x16>
 2ec:	83 e0       	ldi	r24, 0x03	; 3
 2ee:	d9 cf       	rjmp	.-78     	; 0x2a2 <pinMode.constprop.6+0x16>

000002f0 <main>:
main():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 2f0:	83 e0       	ldi	r24, 0x03	; 3
 2f2:	8a bd       	out	0x2a, r24	; 42
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 2f4:	83 bf       	out	0x33, r24	; 51
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 2f6:	78 94       	sei
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1167

  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
 2f8:	89 b7       	in	r24, 0x39	; 57
 2fa:	82 60       	ori	r24, 0x02	; 2
 2fc:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
 2fe:	80 e4       	ldi	r24, 0x40	; 64
 300:	8c bd       	out	0x2c, r24	; 44
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 302:	8f ef       	ldi	r24, 0xFF	; 255
 304:	8d bd       	out	0x2d, r24	; 45
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
 306:	87 ec       	ldi	r24, 0xC7	; 199
 308:	80 bf       	out	0x30, r24	; 48
main():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 30a:	87 e8       	ldi	r24, 0x87	; 135
 30c:	86 b9       	out	0x06, r24	; 6
shutdown():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:77
int LedControl::getDeviceCount() {
    return maxDevices;
}

void LedControl::shutdown(int addr, bool b) {
    if(addr<0 || addr>=maxDevices)
 30e:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 312:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 316:	18 16       	cp	r1, r24
 318:	19 06       	cpc	r1, r25
 31a:	2c f4       	brge	.+10     	; 0x326 <main+0x36>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:82
        return;
    if(b)
        spiTransfer(addr, OP_SHUTDOWN,0);
    else
        spiTransfer(addr, OP_SHUTDOWN,1);
 31c:	41 e0       	ldi	r20, 0x01	; 1
 31e:	6c e0       	ldi	r22, 0x0C	; 12
 320:	90 e0       	ldi	r25, 0x00	; 0
 322:	80 e0       	ldi	r24, 0x00	; 0
 324:	f6 de       	rcall	.-532    	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
setIntensity():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:93
    if(limit>=0 && limit<8)
        spiTransfer(addr, OP_SCANLIMIT,limit);
}

void LedControl::setIntensity(int addr, int intensity) {
    if(addr<0 || addr>=maxDevices)
 326:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 32a:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 32e:	18 16       	cp	r1, r24
 330:	19 06       	cpc	r1, r25
 332:	2c f4       	brge	.+10     	; 0x33e <main+0x4e>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:96
        return;
    if(intensity>=0 && intensity<16)	
        spiTransfer(addr, OP_INTENSITY,intensity);
 334:	4f e0       	ldi	r20, 0x0F	; 15
 336:	6a e0       	ldi	r22, 0x0A	; 10
 338:	90 e0       	ldi	r25, 0x00	; 0
 33a:	80 e0       	ldi	r24, 0x00	; 0
 33c:	ea de       	rcall	.-556    	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
clearDisplay():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:102
}

void LedControl::clearDisplay(int addr) {
    int offset;

    if(addr<0 || addr>=maxDevices)
 33e:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 342:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 346:	18 16       	cp	r1, r24
 348:	19 06       	cpc	r1, r25
 34a:	1c f4       	brge	.+6      	; 0x352 <main+0x62>
 34c:	90 e0       	ldi	r25, 0x00	; 0
 34e:	80 e0       	ldi	r24, 0x00	; 0
 350:	42 df       	rcall	.-380    	; 0x1d6 <LedControl::clearDisplay(int) [clone .part.3] [clone .constprop.10]>
 352:	60 e7       	ldi	r22, 0x70	; 112
 354:	70 e0       	ldi	r23, 0x00	; 0
main():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/main.cpp:4
#include <Arduino.h>

int main(void)
{
 356:	e0 e6       	ldi	r30, 0x60	; 96
 358:	f0 e0       	ldi	r31, 0x00	; 0
setup():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:28
  lc.setIntensity(0,15);
  lc.clearDisplay(0);  

  for (int x = 0; x < 8; x++) {
    for (int y = 0; y < 8; y++) {
      pixels[x] = pixels[x] & ~(1 << y);
 35a:	c1 e0       	ldi	r28, 0x01	; 1
 35c:	d0 e0       	ldi	r29, 0x00	; 0
 35e:	21 91       	ld	r18, Z+
 360:	31 91       	ld	r19, Z+
main():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:27
  lc.shutdown(0,false);       
  lc.setIntensity(0,15);
  lc.clearDisplay(0);  

  for (int x = 0; x < 8; x++) {
    for (int y = 0; y < 8; y++) {
 362:	90 e0       	ldi	r25, 0x00	; 0
 364:	80 e0       	ldi	r24, 0x00	; 0
setup():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:28
      pixels[x] = pixels[x] & ~(1 << y);
 366:	ae 01       	movw	r20, r28
 368:	08 2e       	mov	r0, r24
 36a:	02 c0       	rjmp	.+4      	; 0x370 <main+0x80>
 36c:	44 0f       	add	r20, r20
 36e:	55 1f       	adc	r21, r21
 370:	0a 94       	dec	r0
 372:	e2 f7       	brpl	.-8      	; 0x36c <main+0x7c>
 374:	40 95       	com	r20
 376:	50 95       	com	r21
 378:	24 23       	and	r18, r20
 37a:	35 23       	and	r19, r21
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:27
  lc.shutdown(0,false);       
  lc.setIntensity(0,15);
  lc.clearDisplay(0);  

  for (int x = 0; x < 8; x++) {
    for (int y = 0; y < 8; y++) {
 37c:	01 96       	adiw	r24, 0x01	; 1
 37e:	88 30       	cpi	r24, 0x08	; 8
 380:	91 05       	cpc	r25, r1
 382:	89 f7       	brne	.-30     	; 0x366 <main+0x76>
 384:	df 01       	movw	r26, r30
 386:	12 97       	sbiw	r26, 0x02	; 2
 388:	2d 93       	st	X+, r18
 38a:	3c 93       	st	X, r19
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:26
void setup() {
  lc.shutdown(0,false);       
  lc.setIntensity(0,15);
  lc.clearDisplay(0);  

  for (int x = 0; x < 8; x++) {
 38c:	6e 17       	cp	r22, r30
 38e:	7f 07       	cpc	r23, r31
 390:	31 f7       	brne	.-52     	; 0x35e <main+0x6e>
millis():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:341
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 392:	2f b7       	in	r18, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:345

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 394:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:346
    m = millis_timer_millis;
 396:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <millis_timer_millis>
 39a:	90 91 7f 00 	lds	r25, 0x007F	; 0x80007f <millis_timer_millis+0x1>
 39e:	a0 91 80 00 	lds	r26, 0x0080	; 0x800080 <millis_timer_millis+0x2>
 3a2:	b0 91 81 00 	lds	r27, 0x0081	; 0x800081 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:347
    SREG = oldSREG;
 3a6:	2f bf       	out	0x3f, r18	; 63
setup():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:32
    for (int y = 0; y < 8; y++) {
      pixels[x] = pixels[x] & ~(1 << y);
    }
  }

  prevTime = millis();
 3a8:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <prevTime>
 3ac:	90 93 79 00 	sts	0x0079, r25	; 0x800079 <prevTime+0x1>
 3b0:	a0 93 7a 00 	sts	0x007A, r26	; 0x80007a <prevTime+0x2>
 3b4:	b0 93 7b 00 	sts	0x007B, r27	; 0x80007b <prevTime+0x3>
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:56
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        if (x == j && y == i) {
          pixels[j] = pixels[j] | (1 << i);
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 3b8:	01 e0       	ldi	r16, 0x01	; 1
 3ba:	10 e0       	ldi	r17, 0x00	; 0
millis():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:341
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 3bc:	8f b7       	in	r24, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:345

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 3be:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:346
    m = millis_timer_millis;
 3c0:	40 91 7e 00 	lds	r20, 0x007E	; 0x80007e <millis_timer_millis>
 3c4:	50 91 7f 00 	lds	r21, 0x007F	; 0x80007f <millis_timer_millis+0x1>
 3c8:	60 91 80 00 	lds	r22, 0x0080	; 0x800080 <millis_timer_millis+0x2>
 3cc:	70 91 81 00 	lds	r23, 0x0081	; 0x800081 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:347
    SREG = oldSREG;
 3d0:	8f bf       	out	0x3f, r24	; 63
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:37
  prevTime = millis();
}

void loop() {
  unsigned long t = millis();
  duration += (t - prevTime);
 3d2:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <duration>
 3d6:	90 91 75 00 	lds	r25, 0x0075	; 0x800075 <duration+0x1>
 3da:	a0 91 76 00 	lds	r26, 0x0076	; 0x800076 <duration+0x2>
 3de:	b0 91 77 00 	lds	r27, 0x0077	; 0x800077 <duration+0x3>
 3e2:	84 0f       	add	r24, r20
 3e4:	95 1f       	adc	r25, r21
 3e6:	a6 1f       	adc	r26, r22
 3e8:	b7 1f       	adc	r27, r23
 3ea:	c0 90 78 00 	lds	r12, 0x0078	; 0x800078 <prevTime>
 3ee:	d0 90 79 00 	lds	r13, 0x0079	; 0x800079 <prevTime+0x1>
 3f2:	e0 90 7a 00 	lds	r14, 0x007A	; 0x80007a <prevTime+0x2>
 3f6:	f0 90 7b 00 	lds	r15, 0x007B	; 0x80007b <prevTime+0x3>
 3fa:	8c 19       	sub	r24, r12
 3fc:	9d 09       	sbc	r25, r13
 3fe:	ae 09       	sbc	r26, r14
 400:	bf 09       	sbc	r27, r15
 402:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <duration>
 406:	90 93 75 00 	sts	0x0075, r25	; 0x800075 <duration+0x1>
 40a:	a0 93 76 00 	sts	0x0076, r26	; 0x800076 <duration+0x2>
 40e:	b0 93 77 00 	sts	0x0077, r27	; 0x800077 <duration+0x3>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:38
  prevTime = t;
 412:	40 93 78 00 	sts	0x0078, r20	; 0x800078 <prevTime>
 416:	50 93 79 00 	sts	0x0079, r21	; 0x800079 <prevTime+0x1>
 41a:	60 93 7a 00 	sts	0x007A, r22	; 0x80007a <prevTime+0x2>
 41e:	70 93 7b 00 	sts	0x007B, r23	; 0x80007b <prevTime+0x3>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:39
  if (duration > 100) {
 422:	85 36       	cpi	r24, 0x65	; 101
 424:	91 05       	cpc	r25, r1
 426:	a1 05       	cpc	r26, r1
 428:	b1 05       	cpc	r27, r1
 42a:	40 f2       	brcs	.-112    	; 0x3bc <main+0xcc>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:40
    duration = 0;
 42c:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <duration>
 430:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <duration+0x1>
 434:	10 92 76 00 	sts	0x0076, r1	; 0x800076 <duration+0x2>
 438:	10 92 77 00 	sts	0x0077, r1	; 0x800077 <duration+0x3>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:42

    x += 1;
 43c:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <x>
 440:	90 91 73 00 	lds	r25, 0x0073	; 0x800073 <x+0x1>
 444:	01 96       	adiw	r24, 0x01	; 1
 446:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <x+0x1>
 44a:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <x>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:43
    if (x >= 8) {
 44e:	08 97       	sbiw	r24, 0x08	; 8
 450:	8c f0       	brlt	.+34     	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
 452:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <y>
 456:	90 91 71 00 	lds	r25, 0x0071	; 0x800071 <y+0x1>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:44
      x = 0;
 45a:	10 92 73 00 	sts	0x0073, r1	; 0x800073 <x+0x1>
 45e:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <x>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:45
      y += 1;
 462:	01 96       	adiw	r24, 0x01	; 1
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:46
      if (y >= 8) {
 464:	88 30       	cpi	r24, 0x08	; 8
 466:	91 05       	cpc	r25, r1
 468:	0c f0       	brlt	.+2      	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
 46a:	4f c0       	rjmp	.+158    	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:45
    duration = 0;

    x += 1;
    if (x >= 8) {
      x = 0;
      y += 1;
 46c:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <y+0x1>
 470:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <y>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:53
      }
    }

    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        if (x == j && y == i) {
 474:	a0 91 72 00 	lds	r26, 0x0072	; 0x800072 <x>
 478:	b0 91 73 00 	lds	r27, 0x0073	; 0x800073 <x+0x1>
 47c:	c0 91 70 00 	lds	r28, 0x0070	; 0x800070 <y>
 480:	d0 91 71 00 	lds	r29, 0x0071	; 0x800071 <y+0x1>
 484:	30 e0       	ldi	r19, 0x00	; 0
 486:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:56
          pixels[j] = pixels[j] | (1 << i);
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 488:	b8 01       	movw	r22, r16
 48a:	02 2e       	mov	r0, r18
 48c:	02 c0       	rjmp	.+4      	; 0x492 <__LOCK_REGION_LENGTH__+0x92>
 48e:	66 0f       	add	r22, r22
 490:	77 1f       	adc	r23, r23
 492:	0a 94       	dec	r0
 494:	e2 f7       	brpl	.-8      	; 0x48e <__LOCK_REGION_LENGTH__+0x8e>
 496:	7b 01       	movw	r14, r22
 498:	e0 94       	com	r14
 49a:	f0 94       	com	r15
 49c:	e0 e6       	ldi	r30, 0x60	; 96
 49e:	f0 e0       	ldi	r31, 0x00	; 0
main():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:52
        y = 0;
      }
    }

    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
 4a0:	50 e0       	ldi	r21, 0x00	; 0
 4a2:	40 e0       	ldi	r20, 0x00	; 0
 4a4:	80 81       	ld	r24, Z
 4a6:	91 81       	ldd	r25, Z+1	; 0x01
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:53
        if (x == j && y == i) {
 4a8:	a4 17       	cp	r26, r20
 4aa:	b5 07       	cpc	r27, r21
 4ac:	99 f5       	brne	.+102    	; 0x514 <__LOCK_REGION_LENGTH__+0x114>
 4ae:	c2 17       	cp	r28, r18
 4b0:	d3 07       	cpc	r29, r19
 4b2:	81 f5       	brne	.+96     	; 0x514 <__LOCK_REGION_LENGTH__+0x114>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:54
          pixels[j] = pixels[j] | (1 << i);
 4b4:	86 2b       	or	r24, r22
 4b6:	97 2b       	or	r25, r23
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:56
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 4b8:	91 83       	std	Z+1, r25	; 0x01
 4ba:	80 83       	st	Z, r24
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:52
        y = 0;
      }
    }

    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
 4bc:	4f 5f       	subi	r20, 0xFF	; 255
 4be:	5f 4f       	sbci	r21, 0xFF	; 255
 4c0:	32 96       	adiw	r30, 0x02	; 2
 4c2:	48 30       	cpi	r20, 0x08	; 8
 4c4:	51 05       	cpc	r21, r1
 4c6:	71 f7       	brne	.-36     	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:51
      if (y >= 8) {
        y = 0;
      }
    }

    for (int i = 0; i < 8; i++) {
 4c8:	2f 5f       	subi	r18, 0xFF	; 255
 4ca:	3f 4f       	sbci	r19, 0xFF	; 255
 4cc:	28 30       	cpi	r18, 0x08	; 8
 4ce:	31 05       	cpc	r19, r1
 4d0:	d9 f6       	brne	.-74     	; 0x488 <__LOCK_REGION_LENGTH__+0x88>
 4d2:	c1 e0       	ldi	r28, 0x01	; 1
 4d4:	d0 e0       	ldi	r29, 0x00	; 0
setRow():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:132
    spiTransfer(addr, row+1,status[offset+row]);
}

void LedControl::setRow(int addr, int row, byte value) {
    int offset;
    if(addr<0 || addr>=maxDevices)
 4d6:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 4da:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 4de:	18 16       	cp	r1, r24
 4e0:	19 06       	cpc	r1, r25
 4e2:	74 f4       	brge	.+28     	; 0x500 <__LOCK_REGION_LENGTH__+0x100>
refreshScreen():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:68
}

void refreshScreen() {
  for (int i = 0; i < 8; i++)
  {
    lc.setRow(0, i, pixels[i]);
 4e4:	fe 01       	movw	r30, r28
 4e6:	ee 0f       	add	r30, r30
 4e8:	ff 1f       	adc	r31, r31
 4ea:	e2 5a       	subi	r30, 0xA2	; 162
 4ec:	ff 4f       	sbci	r31, 0xFF	; 255
 4ee:	40 81       	ld	r20, Z
setRow():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:137
        return;
    if(row<0 || row>7)
        return;
    offset=addr*8;
    status[offset+row]=value;
 4f0:	fe 01       	movw	r30, r28
 4f2:	ee 57       	subi	r30, 0x7E	; 126
 4f4:	ff 4f       	sbci	r31, 0xFF	; 255
 4f6:	47 87       	std	Z+15, r20	; 0x0f
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:138
    spiTransfer(addr, row+1,status[offset+row]);
 4f8:	6c 2f       	mov	r22, r28
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	80 e0       	ldi	r24, 0x00	; 0
 4fe:	09 de       	rcall	.-1006   	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
 500:	21 96       	adiw	r28, 0x01	; 1
refreshScreen():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:66
    refreshScreen();
  }
}

void refreshScreen() {
  for (int i = 0; i < 8; i++)
 502:	c9 30       	cpi	r28, 0x09	; 9
 504:	d1 05       	cpc	r29, r1
 506:	39 f7       	brne	.-50     	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
 508:	59 cf       	rjmp	.-334    	; 0x3bc <main+0xcc>
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:47
    x += 1;
    if (x >= 8) {
      x = 0;
      y += 1;
      if (y >= 8) {
        y = 0;
 50a:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <y+0x1>
 50e:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <y>
 512:	b0 cf       	rjmp	.-160    	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:56
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        if (x == j && y == i) {
          pixels[j] = pixels[j] | (1 << i);
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 514:	8e 21       	and	r24, r14
 516:	9f 21       	and	r25, r15
 518:	cf cf       	rjmp	.-98     	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>

0000051a <_GLOBAL__sub_I_pixels>:
_GLOBAL__sub_I_pixels():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:70
void refreshScreen() {
  for (int i = 0; i < 8; i++)
  {
    lc.setRow(0, i, pixels[i]);
  }
}
 51a:	cf 93       	push	r28
 51c:	df 93       	push	r29
__base_ctor ():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:47
#define OP_SCANLIMIT   11
#define OP_SHUTDOWN    12
#define OP_DISPLAYTEST 15

LedControl::LedControl(int dataPin, int clkPin, int csPin, int numDevices) {
    SPI_MOSI=dataPin;
 51e:	10 92 d3 00 	sts	0x00D3, r1	; 0x8000d3 <lc+0x51>
 522:	10 92 d2 00 	sts	0x00D2, r1	; 0x8000d2 <lc+0x50>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:48
    SPI_CLK=clkPin;
 526:	83 e0       	ldi	r24, 0x03	; 3
 528:	90 e0       	ldi	r25, 0x00	; 0
 52a:	90 93 d5 00 	sts	0x00D5, r25	; 0x8000d5 <lc+0x53>
 52e:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <lc+0x52>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:49
    SPI_CS=csPin;
 532:	81 e0       	ldi	r24, 0x01	; 1
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	90 93 d7 00 	sts	0x00D7, r25	; 0x8000d7 <lc+0x55>
 53a:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <lc+0x54>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:52
    if(numDevices<=0 || numDevices>8 )
        numDevices=8;
    maxDevices=numDevices;
 53e:	90 93 d9 00 	sts	0x00D9, r25	; 0x8000d9 <lc+0x57>
 542:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <lc+0x56>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:53
    pinMode(SPI_MOSI,OUTPUT);
 546:	80 e0       	ldi	r24, 0x00	; 0
 548:	a1 de       	rcall	.-702    	; 0x28c <pinMode.constprop.6>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:54
    pinMode(SPI_CLK,OUTPUT);
 54a:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <lc+0x52>
 54e:	9e de       	rcall	.-708    	; 0x28c <pinMode.constprop.6>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:55
    pinMode(SPI_CS,OUTPUT);
 550:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <lc+0x54>
 554:	9b de       	rcall	.-714    	; 0x28c <pinMode.constprop.6>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:56
    digitalWrite(SPI_CS,HIGH);
 556:	61 e0       	ldi	r22, 0x01	; 1
 558:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <lc+0x54>
 55c:	8b dd       	rcall	.-1258   	; 0x74 <digitalWrite>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:57
    SPI_MOSI=dataPin;
 55e:	10 92 d3 00 	sts	0x00D3, r1	; 0x8000d3 <lc+0x51>
 562:	10 92 d2 00 	sts	0x00D2, r1	; 0x8000d2 <lc+0x50>
 566:	e2 e9       	ldi	r30, 0x92	; 146
 568:	f0 e0       	ldi	r31, 0x00	; 0
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:59
    for(int i=0;i<64;i++) 
        status[i]=0x00;
 56a:	11 92       	st	Z+, r1
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:58
    pinMode(SPI_MOSI,OUTPUT);
    pinMode(SPI_CLK,OUTPUT);
    pinMode(SPI_CS,OUTPUT);
    digitalWrite(SPI_CS,HIGH);
    SPI_MOSI=dataPin;
    for(int i=0;i<64;i++) 
 56c:	80 e0       	ldi	r24, 0x00	; 0
 56e:	e2 3d       	cpi	r30, 0xD2	; 210
 570:	f8 07       	cpc	r31, r24
 572:	d9 f7       	brne	.-10     	; 0x56a <_GLOBAL__sub_I_pixels+0x50>
_GLOBAL__sub_I_pixels():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:60
        status[i]=0x00;
    for(int i=0;i<maxDevices;i++) {
 574:	d0 e0       	ldi	r29, 0x00	; 0
 576:	c0 e0       	ldi	r28, 0x00	; 0
__base_ctor ():
 578:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 57c:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 580:	c8 17       	cp	r28, r24
 582:	d9 07       	cpc	r29, r25
 584:	4c f5       	brge	.+82     	; 0x5d8 <_GLOBAL__sub_I_pixels+0xbe>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:61
        spiTransfer(i,OP_DISPLAYTEST,0);
 586:	40 e0       	ldi	r20, 0x00	; 0
 588:	6f e0       	ldi	r22, 0x0F	; 15
 58a:	ce 01       	movw	r24, r28
 58c:	c2 dd       	rcall	.-1148   	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
setScanLimit():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:86
    else
        spiTransfer(addr, OP_SHUTDOWN,1);
}

void LedControl::setScanLimit(int addr, int limit) {
    if(addr<0 || addr>=maxDevices)
 58e:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 592:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 596:	c8 17       	cp	r28, r24
 598:	d9 07       	cpc	r29, r25
 59a:	24 f4       	brge	.+8      	; 0x5a4 <_GLOBAL__sub_I_pixels+0x8a>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:89
        return;
    if(limit>=0 && limit<8)
        spiTransfer(addr, OP_SCANLIMIT,limit);
 59c:	47 e0       	ldi	r20, 0x07	; 7
 59e:	6b e0       	ldi	r22, 0x0B	; 11
 5a0:	ce 01       	movw	r24, r28
 5a2:	b7 dd       	rcall	.-1170   	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
__base_ctor ():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:65
    for(int i=0;i<maxDevices;i++) {
        spiTransfer(i,OP_DISPLAYTEST,0);
        //scanlimit is set to max on startup
        setScanLimit(i,7);
        //decode is done in source
        spiTransfer(i,OP_DECODEMODE,0);
 5a4:	40 e0       	ldi	r20, 0x00	; 0
 5a6:	69 e0       	ldi	r22, 0x09	; 9
 5a8:	ce 01       	movw	r24, r28
 5aa:	b3 dd       	rcall	.-1178   	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
clearDisplay():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:102
}

void LedControl::clearDisplay(int addr) {
    int offset;

    if(addr<0 || addr>=maxDevices)
 5ac:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 5b0:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 5b4:	c8 17       	cp	r28, r24
 5b6:	d9 07       	cpc	r29, r25
 5b8:	14 f4       	brge	.+4      	; 0x5be <_GLOBAL__sub_I_pixels+0xa4>
 5ba:	ce 01       	movw	r24, r28
 5bc:	0c de       	rcall	.-1000   	; 0x1d6 <LedControl::clearDisplay(int) [clone .part.3] [clone .constprop.10]>
shutdown():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:77
int LedControl::getDeviceCount() {
    return maxDevices;
}

void LedControl::shutdown(int addr, bool b) {
    if(addr<0 || addr>=maxDevices)
 5be:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <lc+0x56>
 5c2:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <lc+0x57>
 5c6:	c8 17       	cp	r28, r24
 5c8:	d9 07       	cpc	r29, r25
 5ca:	24 f4       	brge	.+8      	; 0x5d4 <_GLOBAL__sub_I_pixels+0xba>
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:80
        return;
    if(b)
        spiTransfer(addr, OP_SHUTDOWN,0);
 5cc:	40 e0       	ldi	r20, 0x00	; 0
 5ce:	6c e0       	ldi	r22, 0x0C	; 12
 5d0:	ce 01       	movw	r24, r28
 5d2:	9f dd       	rcall	.-1218   	; 0x112 <LedControl::spiTransfer(int, unsigned char, unsigned char) [clone .constprop.13]>
__base_ctor ():
c:\Users\m039\Documents\Arduino\libraries\LedControl\src/LedControl.cpp:60
    pinMode(SPI_CS,OUTPUT);
    digitalWrite(SPI_CS,HIGH);
    SPI_MOSI=dataPin;
    for(int i=0;i<64;i++) 
        status[i]=0x00;
    for(int i=0;i<maxDevices;i++) {
 5d4:	21 96       	adiw	r28, 0x01	; 1
 5d6:	d0 cf       	rjmp	.-96     	; 0x578 <_GLOBAL__sub_I_pixels+0x5e>
_GLOBAL__sub_I_pixels():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychainATtiny85/LedKeychainATtiny85.ino:70
 5d8:	df 91       	pop	r29
 5da:	cf 91       	pop	r28
 5dc:	08 95       	ret

000005de <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 5de:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 5e0:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 5e2:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 5e4:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 5e6:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 5e8:	09 94       	ijmp

000005ea <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 5ea:	f8 94       	cli

000005ec <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 5ec:	ff cf       	rjmp	.-2      	; 0x5ec <__stop_program>
