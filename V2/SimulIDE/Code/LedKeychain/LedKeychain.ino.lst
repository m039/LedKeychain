
C:\Users\m039\AppData\Local\arduino\sketches\847555AAB13B833247BF197DCB22D745/LedKeychain.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	39 c0       	rjmp	.+114    	; 0x74 <__ctors_end>
   2:	51 c0       	rjmp	.+162    	; 0xa6 <__bad_interrupt>
   4:	50 c0       	rjmp	.+160    	; 0xa6 <__bad_interrupt>
   6:	4f c0       	rjmp	.+158    	; 0xa6 <__bad_interrupt>
   8:	4e c0       	rjmp	.+156    	; 0xa6 <__bad_interrupt>
   a:	4d c0       	rjmp	.+154    	; 0xa6 <__bad_interrupt>
   c:	ab c0       	rjmp	.+342    	; 0x164 <__vector_6>
   e:	4b c0       	rjmp	.+150    	; 0xa6 <__bad_interrupt>
  10:	4a c0       	rjmp	.+148    	; 0xa6 <__bad_interrupt>
  12:	49 c0       	rjmp	.+146    	; 0xa6 <__bad_interrupt>
  14:	48 c0       	rjmp	.+144    	; 0xa6 <__bad_interrupt>
  16:	47 c0       	rjmp	.+142    	; 0xa6 <__bad_interrupt>
  18:	46 c0       	rjmp	.+140    	; 0xa6 <__bad_interrupt>
  1a:	45 c0       	rjmp	.+138    	; 0xa6 <__bad_interrupt>
  1c:	44 c0       	rjmp	.+136    	; 0xa6 <__bad_interrupt>
  1e:	43 c0       	rjmp	.+134    	; 0xa6 <__bad_interrupt>
  20:	42 c0       	rjmp	.+132    	; 0xa6 <__bad_interrupt>
  22:	41 c0       	rjmp	.+130    	; 0xa6 <__bad_interrupt>
  24:	40 c0       	rjmp	.+128    	; 0xa6 <__bad_interrupt>
  26:	3f c0       	rjmp	.+126    	; 0xa6 <__bad_interrupt>
  28:	3e c0       	rjmp	.+124    	; 0xa6 <__bad_interrupt>

0000002a <__trampolines_end>:
__trampolines_start():
  2a:	00 00       	nop
  2c:	00 00       	nop
  2e:	00 00       	nop
  30:	00 02       	muls	r16, r16
  32:	00 00       	nop
  34:	00 01       	movw	r0, r0
  36:	03 04       	cpc	r0, r3
  38:	00 00       	nop
	...

0000003c <port_to_output_PGM>:
  3c:	00 00 3b 00 38 00 00 00 32 00                       ..;.8...2.

00000046 <port_to_mode_PGM>:
  46:	00 00 3a 00 37 00 00 00 31 00                       ..:.7...1.

00000050 <digital_pin_to_port_PGM>:
  50:	04 04 01 01 04 04 04 04 04 02 02 02 02 02 02 02     ................
  60:	02 01                                               ..

00000062 <digital_pin_to_bit_mask_PGM>:
  62:	01 02 02 01 04 08 10 20 40 01 02 04 08 10 20 40     ....... @..... @
  72:	80 04                                               ..

00000074 <__ctors_end>:
__dtors_end():
  74:	11 24       	eor	r1, r1
  76:	1f be       	out	0x3f, r1	; 63
  78:	cf ed       	ldi	r28, 0xDF	; 223
  7a:	cd bf       	out	0x3d, r28	; 61

0000007c <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  7c:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  7e:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  80:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  82:	ec e4       	ldi	r30, 0x4C	; 76
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  84:	f4 e0       	ldi	r31, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  86:	02 c0       	rjmp	.+4      	; 0x8c <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  88:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  8a:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  8c:	a0 38       	cpi	r26, 0x80	; 128
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  8e:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  90:	d9 f7       	brne	.-10     	; 0x88 <__do_copy_data+0xc>

00000092 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  92:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  94:	a0 e8       	ldi	r26, 0x80	; 128
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  96:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  98:	01 c0       	rjmp	.+2      	; 0x9c <.do_clear_bss_start>

0000009a <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  9a:	1d 92       	st	X+, r1

0000009c <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  9c:	a5 3a       	cpi	r26, 0xA5	; 165
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  9e:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  a0:	e1 f7       	brne	.-8      	; 0x9a <.do_clear_bss_loop>
.do_clear_bss_start():
  a2:	aa d0       	rcall	.+340    	; 0x1f8 <main>
  a4:	d1 c1       	rjmp	.+930    	; 0x448 <_exit>

000000a6 <__bad_interrupt>:
__vector_1():
  a6:	ac cf       	rjmp	.-168    	; 0x0 <__vectors>

000000a8 <pinMode.constprop.0>:
pinMode.constprop.0():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:34
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  a8:	87 fd       	sbrc	r24, 7
  aa:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:35
  uint8_t bit = digitalPinToBitMask(pin);
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	fc 01       	movw	r30, r24
  b0:	ee 59       	subi	r30, 0x9E	; 158
  b2:	ff 4f       	sbci	r31, 0xFF	; 255
  b4:	24 91       	lpm	r18, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
  b6:	80 5b       	subi	r24, 0xB0	; 176
  b8:	9f 4f       	sbci	r25, 0xFF	; 255
  ba:	fc 01       	movw	r30, r24
  bc:	84 91       	lpm	r24, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
  be:	88 23       	and	r24, r24
  c0:	99 f0       	breq	.+38     	; 0xe8 <__stack+0x9>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:41

  reg = portModeRegister(port);
  c2:	90 e0       	ldi	r25, 0x00	; 0
  c4:	88 0f       	add	r24, r24
  c6:	99 1f       	adc	r25, r25
  c8:	fc 01       	movw	r30, r24
  ca:	ea 5b       	subi	r30, 0xBA	; 186
  cc:	ff 4f       	sbci	r31, 0xFF	; 255
  ce:	a5 91       	lpm	r26, Z+
  d0:	b4 91       	lpm	r27, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:42
  out = portOutputRegister(port);
  d2:	fc 01       	movw	r30, r24
  d4:	e4 5c       	subi	r30, 0xC4	; 196
  d6:	ff 4f       	sbci	r31, 0xFF	; 255
  d8:	85 91       	lpm	r24, Z+
  da:	94 91       	lpm	r25, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
  dc:	8f b7       	in	r24, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:58
                cli();
  de:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
  e0:	ec 91       	ld	r30, X
  e2:	e2 2b       	or	r30, r18
  e4:	ec 93       	st	X, r30
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
  e6:	8f bf       	out	0x3f, r24	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:62
  }
}
  e8:	08 95       	ret

000000ea <digitalWrite>:
digitalWrite():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:138
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  ea:	87 fd       	sbrc	r24, 7
  ec:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:139
  uint8_t timer = digitalPinToTimer(pin);
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	fc 01       	movw	r30, r24
  f2:	e6 5d       	subi	r30, 0xD6	; 214
  f4:	ff 4f       	sbci	r31, 0xFF	; 255
  f6:	34 91       	lpm	r19, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:140
  uint8_t bit = digitalPinToBitMask(pin);
  f8:	fc 01       	movw	r30, r24
  fa:	ee 59       	subi	r30, 0x9E	; 158
  fc:	ff 4f       	sbci	r31, 0xFF	; 255
  fe:	24 91       	lpm	r18, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:141
  uint8_t port = digitalPinToPort(pin);
 100:	fc 01       	movw	r30, r24
 102:	e0 5b       	subi	r30, 0xB0	; 176
 104:	ff 4f       	sbci	r31, 0xFF	; 255
 106:	e4 91       	lpm	r30, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:144
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
 108:	ee 23       	and	r30, r30
 10a:	b9 f0       	breq	.+46     	; 0x13a <digitalWrite+0x50>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:148

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 10c:	33 23       	and	r19, r19
 10e:	29 f0       	breq	.+10     	; 0x11a <digitalWrite+0x30>
turnOffPWM():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
    if( timer == TIMER0A){
 110:	31 30       	cpi	r19, 0x01	; 1
 112:	a1 f4       	brne	.+40     	; 0x13c <digitalWrite+0x52>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:68
      cbi(TCCR0A, COM0A1);
 114:	80 b7       	in	r24, 0x30	; 48
 116:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
      cbi(TCCR0A, COM0B1);
 118:	80 bf       	out	0x30, r24	; 48
digitalWrite():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:150

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
 11a:	f0 e0       	ldi	r31, 0x00	; 0
 11c:	ee 0f       	add	r30, r30
 11e:	ff 1f       	adc	r31, r31
 120:	e4 5c       	subi	r30, 0xC4	; 196
 122:	ff 4f       	sbci	r31, 0xFF	; 255
 124:	a5 91       	lpm	r26, Z+
 126:	b4 91       	lpm	r27, Z
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:153

  if (val == LOW) {
    uint8_t oldSREG = SREG;
 128:	8f b7       	in	r24, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 12a:	61 11       	cpse	r22, r1
 12c:	17 c0       	rjmp	.+46     	; 0x15c <digitalWrite+0x72>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:154
    uint8_t oldSREG = SREG;
    cli();
 12e:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
 130:	ec 91       	ld	r30, X
 132:	20 95       	com	r18
 134:	2e 23       	and	r18, r30
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
 136:	2c 93       	st	X, r18
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
 138:	8f bf       	out	0x3f, r24	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:163
  }
}
 13a:	08 95       	ret
turnOffPWM():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:73
      cbi(TCCR0A, COM0A1);
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
 13c:	32 30       	cpi	r19, 0x02	; 2
 13e:	19 f4       	brne	.+6      	; 0x146 <digitalWrite+0x5c>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      cbi(TCCR0A, COM0B1);
 140:	80 b7       	in	r24, 0x30	; 48
 142:	8f 7d       	andi	r24, 0xDF	; 223
 144:	e9 cf       	rjmp	.-46     	; 0x118 <digitalWrite+0x2e>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:118
        GTCCR &= ~(1<<COM1B1);
        //cbi(GTCCR, COM1B1);
      } else
    #endif
    #if defined(TCCR1A) && defined(COM1A1) // civilized parts
      if( timer == TIMER1A){
 146:	33 30       	cpi	r19, 0x03	; 3
 148:	21 f4       	brne	.+8      	; 0x152 <digitalWrite+0x68>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:119
        TCCR1A &= ~(1<<COM1A1);
 14a:	8f b5       	in	r24, 0x2f	; 47
 14c:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:126
      } else
    #endif

    #if defined(TCCR1A) && defined(COM1B1) // civilized parts
      if( timer == TIMER1B){
        TCCR1A &= ~(1<<COM1B1);
 14e:	8f bd       	out	0x2f, r24	; 47
 150:	e4 cf       	rjmp	.-56     	; 0x11a <digitalWrite+0x30>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:125
        //cbi(TCCR1A, COM1A0);
      } else
    #endif

    #if defined(TCCR1A) && defined(COM1B1) // civilized parts
      if( timer == TIMER1B){
 152:	34 30       	cpi	r19, 0x04	; 4
 154:	11 f7       	brne	.-60     	; 0x11a <digitalWrite+0x30>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:126
        TCCR1A &= ~(1<<COM1B1);
 156:	8f b5       	in	r24, 0x2f	; 47
 158:	8f 7d       	andi	r24, 0xDF	; 223
 15a:	f9 cf       	rjmp	.-14     	; 0x14e <digitalWrite+0x64>
digitalWrite():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:159
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 15c:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
 15e:	ec 91       	ld	r30, X
 160:	2e 2b       	or	r18, r30
 162:	e9 cf       	rjmp	.-46     	; 0x136 <digitalWrite+0x4c>

00000164 <__vector_6>:
__vector_6():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:308
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
 164:	1f 92       	push	r1
 166:	0f 92       	push	r0
 168:	0f b6       	in	r0, 0x3f	; 63
 16a:	0f 92       	push	r0
 16c:	11 24       	eor	r1, r1
 16e:	2f 93       	push	r18
 170:	3f 93       	push	r19
 172:	8f 93       	push	r24
 174:	9f 93       	push	r25
 176:	af 93       	push	r26
 178:	bf 93       	push	r27
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:311
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
 17a:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <millis_timer_millis>
 17e:	90 91 a2 00 	lds	r25, 0x00A2	; 0x8000a2 <millis_timer_millis+0x1>
 182:	a0 91 a3 00 	lds	r26, 0x00A3	; 0x8000a3 <millis_timer_millis+0x2>
 186:	b0 91 a4 00 	lds	r27, 0x00A4	; 0x8000a4 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:312
    unsigned char f = millis_timer_fract;
 18a:	30 91 a0 00 	lds	r19, 0x00A0	; 0x8000a0 <millis_timer_fract>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:319
    static unsigned char correct_exact = 0;     // rollover intended
    if (++correct_exact < CORRECT_EXACT_MANY) {
      ++f;
    }
#endif
    f += FRACT_INC;
 18e:	26 e0       	ldi	r18, 0x06	; 6
 190:	23 0f       	add	r18, r19
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:321

    if (f >= FRACT_MAX)
 192:	2d 37       	cpi	r18, 0x7D	; 125
 194:	68 f1       	brcs	.+90     	; 0x1f0 <__vector_6+0x8c>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:323
    {
      f -= FRACT_MAX;
 196:	29 e8       	ldi	r18, 0x89	; 137
 198:	23 0f       	add	r18, r19
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:324
      m += MILLIS_INC + 1;
 19a:	03 96       	adiw	r24, 0x03	; 3
 19c:	a1 1d       	adc	r26, r1
 19e:	b1 1d       	adc	r27, r1
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:331
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
 1a0:	20 93 a0 00 	sts	0x00A0, r18	; 0x8000a0 <millis_timer_fract>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:332
    millis_timer_millis = m;
 1a4:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <millis_timer_millis>
 1a8:	90 93 a2 00 	sts	0x00A2, r25	; 0x8000a2 <millis_timer_millis+0x1>
 1ac:	a0 93 a3 00 	sts	0x00A3, r26	; 0x8000a3 <millis_timer_millis+0x2>
 1b0:	b0 93 a4 00 	sts	0x00A4, r27	; 0x8000a4 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:334
#ifndef CORRECT_EXACT_MICROS
    millis_timer_overflow_count++;
 1b4:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <millis_timer_overflow_count>
 1b8:	90 91 9d 00 	lds	r25, 0x009D	; 0x80009d <millis_timer_overflow_count+0x1>
 1bc:	a0 91 9e 00 	lds	r26, 0x009E	; 0x80009e <millis_timer_overflow_count+0x2>
 1c0:	b0 91 9f 00 	lds	r27, 0x009F	; 0x80009f <millis_timer_overflow_count+0x3>
 1c4:	01 96       	adiw	r24, 0x01	; 1
 1c6:	a1 1d       	adc	r26, r1
 1c8:	b1 1d       	adc	r27, r1
 1ca:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <millis_timer_overflow_count>
 1ce:	90 93 9d 00 	sts	0x009D, r25	; 0x80009d <millis_timer_overflow_count+0x1>
 1d2:	a0 93 9e 00 	sts	0x009E, r26	; 0x80009e <millis_timer_overflow_count+0x2>
 1d6:	b0 93 9f 00 	sts	0x009F, r27	; 0x80009f <millis_timer_overflow_count+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:336
#endif
  }
 1da:	bf 91       	pop	r27
 1dc:	af 91       	pop	r26
 1de:	9f 91       	pop	r25
 1e0:	8f 91       	pop	r24
 1e2:	3f 91       	pop	r19
 1e4:	2f 91       	pop	r18
 1e6:	0f 90       	pop	r0
 1e8:	0f be       	out	0x3f, r0	; 63
 1ea:	0f 90       	pop	r0
 1ec:	1f 90       	pop	r1
 1ee:	18 95       	reti
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:328
      f -= FRACT_MAX;
      m += MILLIS_INC + 1;
    }
    else
    {
      m += MILLIS_INC;
 1f0:	02 96       	adiw	r24, 0x02	; 2
 1f2:	a1 1d       	adc	r26, r1
 1f4:	b1 1d       	adc	r27, r1
 1f6:	d4 cf       	rjmp	.-88     	; 0x1a0 <__vector_6+0x3c>

000001f8 <main>:
main():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 1f8:	83 e0       	ldi	r24, 0x03	; 3
 1fa:	80 bf       	out	0x30, r24	; 48
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 1fc:	83 bf       	out	0x33, r24	; 51
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 1fe:	78 94       	sei
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1167

  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
 200:	89 b7       	in	r24, 0x39	; 57
 202:	82 60       	ori	r24, 0x02	; 2
 204:	89 bf       	out	0x39, r24	; 57
 206:	00 e7       	ldi	r16, 0x70	; 112
 208:	10 e0       	ldi	r17, 0x00	; 0
 20a:	c0 e6       	ldi	r28, 0x60	; 96
 20c:	d0 e0       	ldi	r29, 0x00	; 0
setup():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:41
unsigned long prevTime;
unsigned long duration;

void setup() {
  for (int thisPin = 0; thisPin < 8; thisPin++) {
    pinMode(col[thisPin], OUTPUT);
 20e:	e8 80       	ld	r14, Y
 210:	22 96       	adiw	r28, 0x02	; 2
 212:	8e 2d       	mov	r24, r14
 214:	49 df       	rcall	.-366    	; 0xa8 <pinMode.constprop.0>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:42
    pinMode(row[thisPin], OUTPUT);
 216:	f8 01       	movw	r30, r16
 218:	f0 80       	ld	r15, Z
 21a:	0e 5f       	subi	r16, 0xFE	; 254
 21c:	1f 4f       	sbci	r17, 0xFF	; 255
 21e:	8f 2d       	mov	r24, r15
 220:	43 df       	rcall	.-378    	; 0xa8 <pinMode.constprop.0>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:43
    digitalWrite(col[thisPin], HIGH);
 222:	61 e0       	ldi	r22, 0x01	; 1
 224:	8e 2d       	mov	r24, r14
 226:	61 df       	rcall	.-318    	; 0xea <digitalWrite>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:44
    digitalWrite(row[thisPin], HIGH);
 228:	61 e0       	ldi	r22, 0x01	; 1
 22a:	8f 2d       	mov	r24, r15
 22c:	5e df       	rcall	.-324    	; 0xea <digitalWrite>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:40

unsigned long prevTime;
unsigned long duration;

void setup() {
  for (int thisPin = 0; thisPin < 8; thisPin++) {
 22e:	f0 e0       	ldi	r31, 0x00	; 0
 230:	c0 37       	cpi	r28, 0x70	; 112
 232:	df 07       	cpc	r29, r31
 234:	61 f7       	brne	.-40     	; 0x20e <main+0x16>
 236:	e0 e8       	ldi	r30, 0x80	; 128
 238:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:49
    digitalWrite(row[thisPin], HIGH);
  }

  for (int x = 0; x < 8; x++) {
    for (int y = 0; y < 8; y++) {
      pixels[x] = pixels[x] & ~(1 << y);
 23a:	61 e0       	ldi	r22, 0x01	; 1
 23c:	70 e0       	ldi	r23, 0x00	; 0
 23e:	21 91       	ld	r18, Z+
 240:	31 91       	ld	r19, Z+
main():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:48
    digitalWrite(col[thisPin], HIGH);
    digitalWrite(row[thisPin], HIGH);
  }

  for (int x = 0; x < 8; x++) {
    for (int y = 0; y < 8; y++) {
 242:	90 e0       	ldi	r25, 0x00	; 0
 244:	80 e0       	ldi	r24, 0x00	; 0
setup():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:49
      pixels[x] = pixels[x] & ~(1 << y);
 246:	ab 01       	movw	r20, r22
 248:	08 2e       	mov	r0, r24
 24a:	02 c0       	rjmp	.+4      	; 0x250 <main+0x58>
 24c:	44 0f       	add	r20, r20
 24e:	55 1f       	adc	r21, r21
 250:	0a 94       	dec	r0
 252:	e2 f7       	brpl	.-8      	; 0x24c <main+0x54>
 254:	40 95       	com	r20
 256:	50 95       	com	r21
 258:	24 23       	and	r18, r20
 25a:	35 23       	and	r19, r21
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:48
    digitalWrite(col[thisPin], HIGH);
    digitalWrite(row[thisPin], HIGH);
  }

  for (int x = 0; x < 8; x++) {
    for (int y = 0; y < 8; y++) {
 25c:	01 96       	adiw	r24, 0x01	; 1
 25e:	88 30       	cpi	r24, 0x08	; 8
 260:	91 05       	cpc	r25, r1
 262:	89 f7       	brne	.-30     	; 0x246 <main+0x4e>
 264:	df 01       	movw	r26, r30
 266:	12 97       	sbiw	r26, 0x02	; 2
 268:	2d 93       	st	X+, r18
 26a:	3c 93       	st	X, r19
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:47
    pinMode(row[thisPin], OUTPUT);
    digitalWrite(col[thisPin], HIGH);
    digitalWrite(row[thisPin], HIGH);
  }

  for (int x = 0; x < 8; x++) {
 26c:	80 e0       	ldi	r24, 0x00	; 0
 26e:	e0 39       	cpi	r30, 0x90	; 144
 270:	f8 07       	cpc	r31, r24
 272:	29 f7       	brne	.-54     	; 0x23e <main+0x46>
millis():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:341
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 274:	2f b7       	in	r18, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:345

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 276:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:346
    m = millis_timer_millis;
 278:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <millis_timer_millis>
 27c:	90 91 a2 00 	lds	r25, 0x00A2	; 0x8000a2 <millis_timer_millis+0x1>
 280:	a0 91 a3 00 	lds	r26, 0x00A3	; 0x8000a3 <millis_timer_millis+0x2>
 284:	b0 91 a4 00 	lds	r27, 0x00A4	; 0x8000a4 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:347
    SREG = oldSREG;
 288:	2f bf       	out	0x3f, r18	; 63
setup():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:53
    for (int y = 0; y < 8; y++) {
      pixels[x] = pixels[x] & ~(1 << y);
    }
  }

  prevTime = millis();
 28a:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <prevTime>
 28e:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <prevTime+0x1>
 292:	a0 93 9a 00 	sts	0x009A, r26	; 0x80009a <prevTime+0x2>
 296:	b0 93 9b 00 	sts	0x009B, r27	; 0x80009b <prevTime+0x3>
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:77
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        if (x == j && y == i) {
          pixels[j] = pixels[j] | (1 << i);
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 29a:	66 24       	eor	r6, r6
 29c:	63 94       	inc	r6
 29e:	71 2c       	mov	r7, r1
 2a0:	40 e8       	ldi	r20, 0x80	; 128
 2a2:	84 2e       	mov	r8, r20
 2a4:	40 e0       	ldi	r20, 0x00	; 0
 2a6:	94 2e       	mov	r9, r20
millis():
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:341
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 2a8:	8f b7       	in	r24, 0x3f	; 63
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:345

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 2aa:	f8 94       	cli
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:346
    m = millis_timer_millis;
 2ac:	40 91 a1 00 	lds	r20, 0x00A1	; 0x8000a1 <millis_timer_millis>
 2b0:	50 91 a2 00 	lds	r21, 0x00A2	; 0x8000a2 <millis_timer_millis+0x1>
 2b4:	60 91 a3 00 	lds	r22, 0x00A3	; 0x8000a3 <millis_timer_millis+0x2>
 2b8:	70 91 a4 00 	lds	r23, 0x00A4	; 0x8000a4 <millis_timer_millis+0x3>
C:\Users\m039\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:347
    SREG = oldSREG;
 2bc:	8f bf       	out	0x3f, r24	; 63
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:58
  prevTime = millis();
}

void loop() {
  unsigned long t = millis();
  duration += (t - prevTime);
 2be:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <duration>
 2c2:	90 91 95 00 	lds	r25, 0x0095	; 0x800095 <duration+0x1>
 2c6:	a0 91 96 00 	lds	r26, 0x0096	; 0x800096 <duration+0x2>
 2ca:	b0 91 97 00 	lds	r27, 0x0097	; 0x800097 <duration+0x3>
 2ce:	84 0f       	add	r24, r20
 2d0:	95 1f       	adc	r25, r21
 2d2:	a6 1f       	adc	r26, r22
 2d4:	b7 1f       	adc	r27, r23
 2d6:	00 91 98 00 	lds	r16, 0x0098	; 0x800098 <prevTime>
 2da:	10 91 99 00 	lds	r17, 0x0099	; 0x800099 <prevTime+0x1>
 2de:	20 91 9a 00 	lds	r18, 0x009A	; 0x80009a <prevTime+0x2>
 2e2:	30 91 9b 00 	lds	r19, 0x009B	; 0x80009b <prevTime+0x3>
 2e6:	80 1b       	sub	r24, r16
 2e8:	91 0b       	sbc	r25, r17
 2ea:	a2 0b       	sbc	r26, r18
 2ec:	b3 0b       	sbc	r27, r19
 2ee:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <duration>
 2f2:	90 93 95 00 	sts	0x0095, r25	; 0x800095 <duration+0x1>
 2f6:	a0 93 96 00 	sts	0x0096, r26	; 0x800096 <duration+0x2>
 2fa:	b0 93 97 00 	sts	0x0097, r27	; 0x800097 <duration+0x3>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:59
  prevTime = t;
 2fe:	40 93 98 00 	sts	0x0098, r20	; 0x800098 <prevTime>
 302:	50 93 99 00 	sts	0x0099, r21	; 0x800099 <prevTime+0x1>
 306:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <prevTime+0x2>
 30a:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <prevTime+0x3>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:60
  if (duration > 100) {
 30e:	85 36       	cpi	r24, 0x65	; 101
 310:	91 05       	cpc	r25, r1
 312:	a1 05       	cpc	r26, r1
 314:	b1 05       	cpc	r27, r1
 316:	08 f4       	brcc	.+2      	; 0x31a <main+0x122>
 318:	55 c0       	rjmp	.+170    	; 0x3c4 <main+0x1cc>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:61
    duration = 0;
 31a:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <duration>
 31e:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <duration+0x1>
 322:	10 92 96 00 	sts	0x0096, r1	; 0x800096 <duration+0x2>
 326:	10 92 97 00 	sts	0x0097, r1	; 0x800097 <duration+0x3>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:63

    x += 1;
 32a:	80 91 92 00 	lds	r24, 0x0092	; 0x800092 <x>
 32e:	90 91 93 00 	lds	r25, 0x0093	; 0x800093 <x+0x1>
 332:	01 96       	adiw	r24, 0x01	; 1
 334:	90 93 93 00 	sts	0x0093, r25	; 0x800093 <x+0x1>
 338:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <x>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:64
    if (x >= 8) {
 33c:	08 97       	sbiw	r24, 0x08	; 8
 33e:	8c f0       	brlt	.+34     	; 0x362 <main+0x16a>
 340:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <y>
 344:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <y+0x1>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:65
      x = 0;
 348:	10 92 93 00 	sts	0x0093, r1	; 0x800093 <x+0x1>
 34c:	10 92 92 00 	sts	0x0092, r1	; 0x800092 <x>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:66
      y += 1;
 350:	01 96       	adiw	r24, 0x01	; 1
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:67
      if (y >= 8) {
 352:	88 30       	cpi	r24, 0x08	; 8
 354:	91 05       	cpc	r25, r1
 356:	0c f0       	brlt	.+2      	; 0x35a <main+0x162>
 358:	6f c0       	rjmp	.+222    	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:66
    duration = 0;

    x += 1;
    if (x >= 8) {
      x = 0;
      y += 1;
 35a:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <y+0x1>
 35e:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <y>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:74
      }
    }

    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        if (x == j && y == i) {
 362:	a0 91 92 00 	lds	r26, 0x0092	; 0x800092 <x>
 366:	b0 91 93 00 	lds	r27, 0x0093	; 0x800093 <x+0x1>
 36a:	c0 91 90 00 	lds	r28, 0x0090	; 0x800090 <y>
 36e:	d0 91 91 00 	lds	r29, 0x0091	; 0x800091 <y+0x1>
 372:	30 e0       	ldi	r19, 0x00	; 0
 374:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:77
          pixels[j] = pixels[j] | (1 << i);
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 376:	b3 01       	movw	r22, r6
 378:	02 2e       	mov	r0, r18
 37a:	02 c0       	rjmp	.+4      	; 0x380 <main+0x188>
 37c:	66 0f       	add	r22, r22
 37e:	77 1f       	adc	r23, r23
 380:	0a 94       	dec	r0
 382:	e2 f7       	brpl	.-8      	; 0x37c <main+0x184>
 384:	8b 01       	movw	r16, r22
 386:	00 95       	com	r16
 388:	10 95       	com	r17
 38a:	e0 e8       	ldi	r30, 0x80	; 128
 38c:	f0 e0       	ldi	r31, 0x00	; 0
main():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:73
        y = 0;
      }
    }

    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
 38e:	50 e0       	ldi	r21, 0x00	; 0
 390:	40 e0       	ldi	r20, 0x00	; 0
 392:	80 81       	ld	r24, Z
 394:	91 81       	ldd	r25, Z+1	; 0x01
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:74
        if (x == j && y == i) {
 396:	a4 17       	cp	r26, r20
 398:	b5 07       	cpc	r27, r21
 39a:	09 f0       	breq	.+2      	; 0x39e <main+0x1a6>
 39c:	52 c0       	rjmp	.+164    	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
 39e:	c2 17       	cp	r28, r18
 3a0:	d3 07       	cpc	r29, r19
 3a2:	09 f0       	breq	.+2      	; 0x3a6 <main+0x1ae>
 3a4:	4e c0       	rjmp	.+156    	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:75
          pixels[j] = pixels[j] | (1 << i);
 3a6:	86 2b       	or	r24, r22
 3a8:	97 2b       	or	r25, r23
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:77
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 3aa:	91 83       	std	Z+1, r25	; 0x01
 3ac:	80 83       	st	Z, r24
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:73
        y = 0;
      }
    }

    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
 3ae:	4f 5f       	subi	r20, 0xFF	; 255
 3b0:	5f 4f       	sbci	r21, 0xFF	; 255
 3b2:	32 96       	adiw	r30, 0x02	; 2
 3b4:	48 30       	cpi	r20, 0x08	; 8
 3b6:	51 05       	cpc	r21, r1
 3b8:	61 f7       	brne	.-40     	; 0x392 <main+0x19a>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:72
      if (y >= 8) {
        y = 0;
      }
    }

    for (int i = 0; i < 8; i++) {
 3ba:	2f 5f       	subi	r18, 0xFF	; 255
 3bc:	3f 4f       	sbci	r19, 0xFF	; 255
 3be:	28 30       	cpi	r18, 0x08	; 8
 3c0:	31 05       	cpc	r19, r1
 3c2:	c9 f6       	brne	.-78     	; 0x376 <main+0x17e>
main():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:73
      for (int j = 0; j < 8; j++) {
 3c4:	20 e8       	ldi	r18, 0x80	; 128
 3c6:	c2 2e       	mov	r12, r18
 3c8:	20 e0       	ldi	r18, 0x00	; 0
 3ca:	d2 2e       	mov	r13, r18
 3cc:	00 e7       	ldi	r16, 0x70	; 112
 3ce:	10 e0       	ldi	r17, 0x00	; 0
refreshScreen():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:88
  refreshScreen();
}

void refreshScreen() {
    for (int thisRow = 0; thisRow < 8; thisRow++) {
      digitalWrite(row[thisRow], LOW);
 3d0:	f8 01       	movw	r30, r16
 3d2:	50 80       	ld	r5, Z
 3d4:	0e 5f       	subi	r16, 0xFE	; 254
 3d6:	1f 4f       	sbci	r17, 0xFF	; 255
 3d8:	60 e0       	ldi	r22, 0x00	; 0
 3da:	85 2d       	mov	r24, r5
 3dc:	86 de       	rcall	.-756    	; 0xea <digitalWrite>
 3de:	80 e6       	ldi	r24, 0x60	; 96
 3e0:	a8 2e       	mov	r10, r24
 3e2:	80 e0       	ldi	r24, 0x00	; 0
 3e4:	b8 2e       	mov	r11, r24
 3e6:	97 e0       	ldi	r25, 0x07	; 7
 3e8:	e9 2e       	mov	r14, r25
 3ea:	f1 2c       	mov	r15, r1
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:91

      for (int thisCol = 0; thisCol < 8; thisCol++) {
          int thisPixel = pixels[thisRow] & (1 << 7 - thisCol)? HIGH : LOW;
 3ec:	f6 01       	movw	r30, r12
 3ee:	c0 81       	ld	r28, Z
 3f0:	d1 81       	ldd	r29, Z+1	; 0x01
 3f2:	0e 2c       	mov	r0, r14
 3f4:	02 c0       	rjmp	.+4      	; 0x3fa <main+0x202>
 3f6:	d5 95       	asr	r29
 3f8:	c7 95       	ror	r28
 3fa:	0a 94       	dec	r0
 3fc:	e2 f7       	brpl	.-8      	; 0x3f6 <main+0x1fe>
 3fe:	c1 70       	andi	r28, 0x01	; 1
 400:	dd 27       	eor	r29, r29
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:92
          digitalWrite(col[thisCol], thisPixel);
 402:	f5 01       	movw	r30, r10
 404:	40 80       	ld	r4, Z
 406:	f2 e0       	ldi	r31, 0x02	; 2
 408:	af 0e       	add	r10, r31
 40a:	b1 1c       	adc	r11, r1
 40c:	6c 2f       	mov	r22, r28
 40e:	84 2d       	mov	r24, r4
 410:	6c de       	rcall	.-808    	; 0xea <digitalWrite>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:93
          if (thisPixel == HIGH) {
 412:	cd 2b       	or	r28, r29
 414:	19 f0       	breq	.+6      	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:94
              digitalWrite(col[thisCol], LOW);
 416:	60 e0       	ldi	r22, 0x00	; 0
 418:	84 2d       	mov	r24, r4
 41a:	67 de       	rcall	.-818    	; 0xea <digitalWrite>
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	e8 1a       	sub	r14, r24
 420:	f1 08       	sbc	r15, r1
 422:	20 f7       	brcc	.-56     	; 0x3ec <main+0x1f4>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:98
          }
      }

      digitalWrite(row[thisRow], HIGH);
 424:	61 e0       	ldi	r22, 0x01	; 1
 426:	85 2d       	mov	r24, r5
 428:	60 de       	rcall	.-832    	; 0xea <digitalWrite>
 42a:	f2 e0       	ldi	r31, 0x02	; 2
 42c:	cf 0e       	add	r12, r31
 42e:	d1 1c       	adc	r13, r1
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:87

  refreshScreen();
}

void refreshScreen() {
    for (int thisRow = 0; thisRow < 8; thisRow++) {
 430:	80 16       	cp	r8, r16
 432:	91 06       	cpc	r9, r17
 434:	69 f6       	brne	.-102    	; 0x3d0 <main+0x1d8>
 436:	38 cf       	rjmp	.-400    	; 0x2a8 <main+0xb0>
loop():
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:68
    x += 1;
    if (x >= 8) {
      x = 0;
      y += 1;
      if (y >= 8) {
        y = 0;
 438:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <y+0x1>
 43c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <y>
 440:	90 cf       	rjmp	.-224    	; 0x362 <main+0x16a>
C:\Users\m039\Desktop\Code\LedKeychain\V2\SimulIDE\Code\LedKeychain/LedKeychain.ino:77
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        if (x == j && y == i) {
          pixels[j] = pixels[j] | (1 << i);
        } else {
          pixels[j] = pixels[j] & ~(1 << i);
 442:	80 23       	and	r24, r16
 444:	91 23       	and	r25, r17
 446:	b1 cf       	rjmp	.-158    	; 0x3aa <main+0x1b2>

00000448 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 448:	f8 94       	cli

0000044a <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/tiny-stack/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 44a:	ff cf       	rjmp	.-2      	; 0x44a <__stop_program>
